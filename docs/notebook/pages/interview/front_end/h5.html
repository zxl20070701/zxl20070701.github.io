<header>
    HTML
</header>
<h2>
    一次完整的HTTP事务是怎么一个过程?
</h2>
<ul>
    <li>
        浏览器的地址栏输入URL并按下回车。
    </li>
    <li>
        浏览器查找当前URL是否存在缓存，并比较缓存是否过期。
    </li>
    <li>
        DNS解析URL对应的IP。
    </li>
    <li>
        根据IP建立TCP连接（三次握手）。
    </li>
    <li>
        HTTP发起请求。
    </li>
    <li>
        服务器处理请求，浏览器接收HTTP响应。
    </li>
    <li>
        渲染页面，构建DOM树。
    </li>
    <li>
        关闭TCP连接（四次挥手）。
    </li>
</ul>
<h2>
    img的srcset属性作用？img加载不同图片
</h2>
<p>
    响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到img标签的srcset属性，srcset属性用于设置不同屏幕密度下，img加载图片不同。
</p>
<h2>
    浏览器是如何渲染页面的？
</h2>
<h3>
    1.解析文档构建DOM树
</h3>
<ul>
    <li>
        HTML/XHTML/SVG：解析这三种文件后，会生成DOM树（DOM Tree）
    </li>
    <li>
        CSS：解析样式表，生成CSS规则树（CSS Rule Tree）
    </li>
    <li>
        JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互。
    </li>
</ul>
<h3>
    2.构建渲染树
</h3>
<p>
    解析文档完成后，浏览器引擎会将 CSS Rule Tree 附着到DOM Tree 上，并根据DOM Tree 和 CSS Rule Tree构造 Rendering Tree（渲染树）
</p>
<h3>
    3.布局与绘制渲染树
</h3>
<p>
    解析position, overflow, z-index等等属性，计算每一个渲染树节点的位置和大小，此过程被称为reflow。最后调用操作系统的Native GUI API完成绘制（repain）。
</p>
<h2>
    TCP为什么需要三次握手和四次挥手
</h2>
<p>
    三次握手是为了建立可靠的数据传输通道，四次挥手则是为了保证等数据完成的被接收完再关闭连接。
</p>
<h2>
    TCP三次握手
</h2>
<ul>
    <li>
        当有客户端需要建立连接的时候就会发送一个确定连接的报文，此报文是同步报文SYN = 1，并且会生成一个随机的序号 seq = x，这是第一次握手；
    </li>
    <li>
        当服务端接收到请求连接报文的时候，会发送一个同步报文确认报文，此报文 SYN = 1，并且 ACK = 1，同时服务端也会随机生成一个 seq = y，并将 ack 设置成 x + 1，回传给客户端，这是第二次握手；
    </li>
    <li>
        当客户端接收到服务端的 ACK 报文后，会回复一个 ACK 确认报文，用于确认确认报文已经收到，此报文 ACK = 1，seq = x + 1, ack = y + 1，这是第三次握手。
    </li>
</ul>
<div class="tips">
    大写的 ACK 表示报文的类型是确认报文，小写的 ack 是报文里面的确认号，这个确认号是上一次握手对方的 seq 值加 1 得到。
</div>
<h2>
    TCP四次挥手
</h2>
<ul>
    <li>
        客户端发起 FIN 断开连接的报文，携带随机生成的 seq 值 u，发送给服务端，并且自己处于 FIN-WSIT 状态，这是第一次挥手；
    </li>
    <li>
        服务端接收到 FIN 报文后，回复一个确认报文，其中 ACK = 1，随机生成一个 seq，以及 ack = u + 1，这是第二次挥手；
    </li>
    <li>
        当服务端数据发送完了过后，再发送一个 FIN 报文给客户端，通知客户端，服务端准备关闭连接了，此报文 FIN = 1，ACK = 1，ack = u + 1，seq = w，这是第三次挥手；
    </li>
    <li>
        当客户端收到 FIN 确认报文时再发送一个FIN 的确认报文，其中 ACK = 1，seq = u + 1，ack = w + 1，并进入 TIME-WAIT 状态，当等待 2MSL 后关闭连接，这是第四次挥手。
    </li>
</ul>
<h2>
    Http 短轮询、长轮询
</h2>
<ul>
    <li>
        短轮询：一般是由客户端每隔一段时间(如每隔5s) 向服务器发起一次普通 HTTP 请求 。服务端查询当前接口是否有数据更新，若有数据更新则向客户端返回最新数据，若无则提示客户端无数据更新
    </li>
    <li>
        长轮询： 一般是由客户端向服务端发出一个设置较长网络超时时间的 HTTP 请求，并在Http连接超时前，不主动断开连接；待客户端超时或有数据返回后，再次建立一个同样的Http请求，重复以上过程
    </li>
</ul>